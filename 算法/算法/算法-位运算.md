# 位运算技巧

### 2 的幂

- 2 的幂一定是 $2^n$，二进制下就是第 n 位为 1 其余为 0
- 该数 -1 则第n位变为 0 其余位变为 1
- 即有 $x \& (x-1) = 0$



### 4 的幂

- 4 的幂一定是 2 的幂， $4^n = 2 ^{2m}$
- 4 的幂取 3 的余得 1， $4^n = 4 \times 4^{n-1}, 4^n \text{mod} 3 = 1$
-  即有一个数是 2 的幂同时取 3 的余得 1 即为 4 的幂 $x\ \&(x-1)\ \&\ x\ \text{mod}\ 3\ ==\ 1$



### 二进制中 1 的个数

1. 挪到右边和 1 （0001）按位与一下看是不是 1
2. 循环 和自己 -1 之后按位与 直到自己变成 0
   - 和自己-1后按位与会消去最低的那个 1
   - 循环次数就是 1 的个数



### 或运算

- 或运算没有直接的逆运算
- 想要逆运算可以为或运算的过程记录每一位上1的出现次数
- 倒着算回去的时候 看每一位都还有没有多的 1



### 异或

#### 格雷码

- **n 位格雷码序列** 是一个由 `2n` 个整数组成的序列

- 每个整数都在范围 `[0, 2n - 1]` 内（含 `0` 和 `2n - 1`）

- 第一个整数是 `0`

- 一个整数在序列中出现 **不超过一次**

- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且

- **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

- 公式
  $$
  n_i = i \oplus \lfloor \frac{i}{2} \rfloor
  $$

  ```python
  def grayCode(n: int) -> List[int]:
      return [i^(i >> 1) for i in range(2**n)]
  ```



#### 交换数字

- 不增加空间交换数字

- 其实可以用减法

  ```python
  a, b
  a = b-a
  b = b-a  b-(b-a) = b-b+a = a
  a = a+b  b-a+(a) = b
  ```

  用差记录两者的结合信息，留下其中一个就能推出另一个，推出另一个再推一次就完成交换

- 用按位异或一个道理

  - 按位异或的性质
    1. 相同为 0 不同为 1
    2. $a \oplus 0 = a$
    3. $a \oplus a = 0$
    4. $a\oplus b \oplus b = a \oplus 0 = a$



#### 数数

找出只出现一次的其他数出现偶数次数的唯一的那个数字

- 利用异或性质，和自己异或得 0，和 0 异或得自己
- 即所有数异或在一起留下来的就是单独的那个数



#### 汉明距离

两个数二进制位不同的个数

- 相同为0不同为1，异或性质
- 两数异或后数有多少 1



#### 两数求和

使用位运算实现求和

- 两数求和本质是
  1. 不考虑进位时按位取异或
     - 相同取0（进位）
     - 不同取1（当前位有一个 0 加上一个 1）
  2. 单独处理进位
     - 位相同时该位要进位
       - 用按位与判断相同位
       - 相同位为 1，左移一个和异或结果相加用来给高一位+1
       - 又出现一次加法，递归相加



#### 数字交错

- 和自己右移一位取反做异或比较
  - 想法是好的，但是数字是按byte存的，前面空着的 0 也会被取反影响判断
  - 要额外控制前面的部分
  - **避免使用取反，以应对看不见的位置的变化**

- 相邻两位是否相同
  1. 相邻两位可能为
     - 11
     - 00
     - 10
     - 01
  2. 和 11 做异或依次得到
     - 00
     - 00
     - 01
     - 10
  3. 即相邻不同时和 11 做异或得非 0



### 枚举子集

枚举所有子集情况

- 通过二进制从 0 到满位，第 $i$ 位为 1 代表选择第 $i$ 个数
- 以三个数为例，三个数即三个位，共$2^3-1 = 7$ 种 组合情况（包括不选）
  1. 000 
  2. 001
  3. 011
  4. 100
  5. 101
  6. 110
  7. 111
- 对于下表为 $j$ 的数组
  - 可以将 组合情况 右移 $j$ 位和 1 做与看当前数选不选
  -  也可以将 1 左移和 组合情况 比较



#### 枚举子集的子集

```python
stat = 1 + 4 + 8 + 32 # 101101
t = stat
while stat:
    stat = (stat - 1) & t
```

- 每一步会消去最末尾的 1，然后重制其更低位的 1
- 当最高位的 1 被消去后，低位会重新再来一轮直到所有 1 都被消去

