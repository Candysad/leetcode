# 堆

![Heap-as-array](C:\Users\candy\Desktop\code\leetcode\算法\mdimage\Heap-as-array.svg)

- 完全二叉树 **Complete Binary Tree**
  - 上面全满
  - 最后一排从左到右放



### 操作

以大根堆为例

- 上滤
  - 一个节点及其两个子节点共3个节点比较
  - 将最大的交换至上面
- 下滤
  - 从根节点开始，将不满足大根堆的局部调整，小的值会下放
  - 一个节点及其两个子节点共3个节点比较
  - 将最大的交换至上面



### 建堆

- 依次插入新的节点
- 自顶向下
  - 新节点放在堆末尾
  - 新节点开始上滤
  - 最后一个节点插入后结束
- 自底向上
  - 先将所有节点放入数组
  - 从最后一个局部三节点开始对父节点执行下滤
  - 对根节点执行下滤后结束



### 排序

- 每次弹出堆顶得到 最大 / 最小 值
- 弹出后将当前堆末尾元素放至堆顶根节点，然后根节点开始下滤
- 弹出值按序放在堆空出的空间



### 优先队列

- 输出弹出一个最值
- 输入插入一个新值
- 小根堆
  - 堆顶为最小值
  - 输出弹出后维护堆，将末尾元素放至堆顶然后根节点下滤
  - 输入插入后维护堆，将新插入的末尾元素上滤



### 实现

- **python**

   heapq
  - 可以用长度为 2 的 tuple 或 list 作为元素，前一项为值，后一项为其他信息
  - `heapq.heappush(heap, item)`：将 item 的值加入 heap 中
  - `heapq.heappop(heap)`
    - 弹出并返回 heap 的最小的元素
    - 如果堆为空，抛出 `IndexError `
    - 使用 heap[0] ，可以只访问最小的元素而不弹出它

  - `heapq.heappushpop(heap, item)`
    - 将 item 放入堆中，然后弹出并返回 heap 的最小元素
    - 先插入，再返回
    - 该组合操作比先调用 `heappush()` 再调用 `heappop()` 运行起来更有效率

  - `heapq.heapify(x)`
    - 将list x 转换成堆
    - 原地，线性时间内

  - `heapq.heapreplace(heap, item)`
    - 弹出并返回 heap 中最小的一项，同时推入新的 item
    - 先返回，再插入
    - 堆的大小不变
    - 如果堆为空则引发 `IndexError`
    - 这个单步骤操作比 heappop() 加 heappush() 更高效，并且在使用固定大小的堆时更为适宜。 pop/push 组合总是会从堆中返回一个元素并将其替换为 item

  - `heapq.merge(*iterables, key=None, reverse=False)`：合并为多个堆
  - `heapq.nlargest(n, iterable, key=None)`：返回前 n 个最大元素组成的列表
  - `heapq.nsmallest(n, iterable, key=None)`：返回前 n 个最小元素组成的列表

- C++

  ```c++
  #include <queue>
  
  std::priority_queue<TypeName> q;             // 数据类型为 TypeName
  std::priority_queue<TypeName, Container> q;  // 使用 Container 作为底层容器
  std::priority_queue<TypeName, Container, Compare> q;
  // 使用 Container 作为底层容器，使用 Compare 作为比较类型
  
  // 默认使用底层容器 vector
  // 比较类型 less<TypeName>（此时为它的 top() 返回为最大值）
  // 若希望 top() 返回最小值，可令比较类型为 greater<TypeName>
  // 不可跳过 Container 直接传入 Compare
  
  // 从 C++11 开始，如果使用 lambda 函数自定义 Compare 则需要将其作为构造函数的参数代入
  // 如：
  auto cmp = [](const std::pair<int, int> &l, const std::pair<int, int> &r) {
    return l.second < r.second;
  };
  
  std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int> >, decltype(cmp)> pq(cmp);
  ```

  - 常数复杂度

    - `top()` 访问堆顶元素（此时优先队列不能为空）

    - `empty()` 询问容器是否为空

    - `size()` 查询容器中的元素数量

  - 对数复杂度

    - `push(x)` 插入元素，并对底层容器排序

    - `pop()` 删除堆顶元素（此时优先队列不能为空）
