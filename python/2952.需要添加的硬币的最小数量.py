#
# @lc app=leetcode.cn id=2952 lang=python3
#
# [2952] 需要添加的硬币的最小数量
#

# @lc code=start
class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        '''
        贪心？数学题！
        先考虑所有硬币不重复+不用已有硬币的情况
            1和2必须有，此时能表达到3，所以加入4
            原来可以表达[1,3]，现在加入4，原本的[1,3]可以表达，并额外可以得到[1+4, 3+4]=[5,7]，再加上4自己，得到[1,7]
            规律已经出来了
            定义一种致密的递增序列（目前忽略了重复硬币，所以是严格递增的理想情况）：
                1.元素不重复
                2.可以被其他元素加和表达的元素不需要出现
                3.其中元素加和为sum，致密的序列总能通过元素加和表达[1,sum]中的所有元素
            对于这样有i个元素的致密递增序列Z_i，其元素加和为sum_i
            要使其添加一个新元素后保持致密，即新元素 x 不能被前面的元素表达，同时加入后又能表达[1, sum_{i+1}]
            可以推出：
                对于 Z_i，可以表达[1,sum_i]
                加入sum_i + 1后，可以额外表达 [sum_i + 1, sum_i + sum_i + 1]，使得整体可以表达 [1, 2 sum_i + 1]
                此时 sum_{i+1} = 2sum_i + 1
        
        回到题中，先将已有硬币按面值大小从小到大排序
        一开始没有钱sum_0为0，需要添加 1， 如果已有 1，就不用新添加
        假如此时sum为5，即已经可以表达 [1, 5]中的所有元素
            若下一个还未使用的已有硬币面值为4
                即添加4不能使当前元素致密（换句话说不划算，增长没有理想的那么快）
                但也不是不能用，[1,5] 加入4 后可以额外表达 4 和 [1+4, 5+4] = [5,9]，整体为[1,9] 一样可以增长
            若下一个还未使用的硬币为 7
                此时如果直接加入7，则6没法表达
                因为之前是 [1,5]，加入7之后可以表达的范围是[1,5], 7, [1+7, 5+7]，整体为 [1,5], [7, 12]
                所以应该按照致密条件新添加6，而非使用已有的7
                
        总结：即每次添加要么保持理想的致密条件添加当前不能表达的最小元素(sum_i + 1)，要么已有硬币已经可以被表达，但是添加它也能增长，所以就先增长
        '''
        coins.sort()
        result = 0
        now_sum = 0
        i = 0
        while now_sum < target:
            if i < len(coins) and coins[i] <= now_sum + 1:
                now_sum += coins[i]
                i += 1
            else:
                now_sum += now_sum + 1
                result += 1

        return result    
# @lc code=end

