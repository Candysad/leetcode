#
# @lc app=leetcode.cn id=309 lang=python3
#
# [309] 买卖股票的最佳时机含冷冻期
#

# @lc code=start
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        '''
        dp[i] 记录第i天所有情况下的最大收益的话，每天都要枚举前面某一天买入来找今天卖的话前面哪天买收益最高
        也就是说部分有用的信息没有在状态里直接存下来，状态设计的不好
        但是按照普通dp的思想这些状态互斥，就是不能在一个单位里存下来
        所以就扩充这个单位，把互斥的状态记在同一个坐标里
        
        dp[i] 不同情况下，第i天结束后的最大收益
        dp[i] = (
                今天手上有股票时的最大收益，手上有股票的状态最后一次操作是买，和冻结无关,
                今天手上没有股票、今天结束时也没有冻结（是以前卖的，不是今天卖的，明天还可以买）的最大收益,
                今天手上没有股票、但是冻结了（今天卖的，明天不能买）的最大收益
            )
        
        今天手上有股票的最大收益
            现在手上的股票要么是昨天没股票今天买的（昨天不能刚卖，不然今天冻结），要么是更早的时候手上就有股票
            dp[i][0] = max(dp[i-1][1] - price[i], dp[i-1][0])

        今天手上没有股票，也没有冻结
            今天把股票卖了就冻结了，而今天没有冻结所以是更早就卖了
            要么昨天之前就卖了（取昨天没冻结的状态），今天冻结完了；要么昨天刚冻结一天（取昨天冻结的状态），今天刚解冻
            dp[i][1] = max(dp[i-1][1], dp[i-1][2])
            
        今天手上没有股票，冻结了
            就是昨天卖的，昨天手上有股票
            dp[i][2] = dp[i-1][0] + price[i]
            
        观察所有状态转移，都只用看前一天的状态，所以不需要完整的数组来存放每一天的状态
        '''
        n = len(prices)
        if n == 1:
            return 0
        
        '''
        用d0, d1, d2作为三种情况的状态
        '''
        d0 = -prices[0] #第一天买了，花了第一天股票的价格
        d1 = 0
        d2 = 0
        
        for i in range(1, n):
            d0, d1, d2 = max(d1 - prices[i], d0), max(d1, d2), d0 + prices[i]
        
        return max(d0, d1, d2)
# @lc code=end

